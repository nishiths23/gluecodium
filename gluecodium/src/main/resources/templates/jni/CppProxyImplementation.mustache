{{!!
  !
  ! Copyright (C) 2016-2019 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
{{>java/CopyrightHeader}}

{{#includes}}
{{>common/Include}}
{{/includes}}
#include "ArrayConversionUtils.h"
#include "FieldAccessMethods.h"

{{#internalNamespace}}
namespace {{.}}
{
{{/internalNamespace}}
namespace jni
{

{{#container}}
{{resolveName "mangled"}}_CppProxy::{{resolveName "mangled"}}_CppProxy( JNIEnv* _jenv, JniReference<jobject> globalRef, jint _jHashCode )
    : CppProxyBase( _jenv, std::move( globalRef ), _jHashCode, "{{resolveName "mangled"}}" ) {
}
{{#parentMethods}}
{{>proxyMethod}}
{{/parentMethods}}{{!!

}}{{#functions}}
{{>proxyMethod}}
{{/functions}}
{{/container}}

}
{{#internalNamespace}}
}
{{/internalNamespace}}{{!!

}}{{+proxyMethod}}
{{resolveName returnType "C++"}}
{{resolveName container "mangled"}}_CppProxy::{{#instanceOf container "LimeLambda"}}operator(){{/instanceOf}}{{!!
}}{{#notInstanceOf container "LimeLambda"}}{{resolveName "C++"}}{{/notInstanceOf}}( {{#parameters}}{{!!
}}const {{resolveName typeRef "C++"}}{{#ifPredicate typeRef "needsRefSuffix"}}&{{/ifPredicate}} n{{resolveName}}{{#if iter.hasNext}}, {{/if}}{{!!
}}{{/parameters}} ){{#if attributes.cpp.const}} const{{/if}} {
    JNIEnv* jniEnv = getJniEnvironment( );{{!!
}}{{#parameters}}{{!!
}}{{#unlessPredicate typeRef "isJniPrimitive"}}
    auto j{{resolveName}} = convert_to_jni( jniEnv, n{{resolveName}} );{{!!
}}{{/unlessPredicate}}{{#ifPredicate typeRef "isJniPrimitive"}}
    {{resolveName typeRef}} j{{resolveName}} = n{{resolveName}};{{!!
}}{{/ifPredicate}}{{!!
}}{{/parameters}}
    {{#unless returnType.isJavaVoid}}auto result = {{/unless}}callJavaMethod<{{resolveName returnType}}>( {{!!
    }}"{{resolveName}}", "({{#parameters}}{{resolveName typeRef "signature"}}{{/parameters}}){{!!
    }}{{resolveName returnType "signature"}}", jniEnv {{#if parameters}},{{/if}} {{!!
    }}{{#parameters}}j{{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/parameters}});
{{#if thrownType}}
    auto jException = make_local_ref<jobject>(jniEnv, jniEnv->ExceptionOccurred( ));
    if ( jException )
    {
        jniEnv->ExceptionClear( );
        auto jErrorValue = get_object_field_value(
            jniEnv,
            jException,
            "error",
            "{{resolveName exception.errorType "signature"}}" );
        auto nErrorValue = convert_from_jni(
            jniEnv,
            jErrorValue,
            ({{resolveName exception.errorType "C++ FQN"}}*)nullptr );

{{#instanceOf exception.errorType.type.actualType "LimeEnumeration"}}
        return ::std::error_code{nErrorValue};
{{/instanceOf}}{{#notInstanceOf exception.errorType.type.actualType "LimeEnumeration"}}
        return {{resolveName exception.errorType "C++ FQN"}}{nErrorValue};
{{/notInstanceOf}}
    }
    else
    {
{{/if}}{{#unless thrownType}}
    if ( jniEnv->ExceptionCheck( ) )
    {
        jniEnv->ExceptionDescribe( );
        jniEnv->ExceptionClear( );
        jniEnv->FatalError( "Exception was thrown in Java and it was not handled.\n"
            "See the log for more information about the exception (including Java stack trace)." );
    }
{{/unless}}{{!!
}}{{#unless returnType.isJavaVoid}}
    return {{#unlessPredicate returnType.typeRef "isJniPrimitive"}}convert_from_jni( jniEnv, result, {{!!
    }}({{resolveName returnType "C++"}}{{#if thrownType}}::value_type{{/if}}*)nullptr ){{/unlessPredicate}}{{!!
    }}{{#ifPredicate returnType.typeRef "isJniPrimitive"}}result{{/ifPredicate}};
{{/unless}}
{{#if thrownType}}{{#if returnType.isJavaVoid}}{{#instanceOf exception.errorType.type.actualType "LimeEnumeration"}}
        return ::std::error_code{};
{{/instanceOf}}{{#notInstanceOf exception.errorType.type.actualType "LimeEnumeration"}}
        return {true};
{{/notInstanceOf}}{{/if}}
    }
{{/if}}
}
{{/proxyMethod}}
