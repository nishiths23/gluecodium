{{!!
  !
  ! Copyright (C) 2016-2019 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
{{>java/CopyrightHeader}}

{{#includes}}
{{>common/Include}}
{{/includes}}
#include "ArrayConversionUtils.h"
#include "JniClassCache.h"
#include "JniReference.h"
#include "JniWrapperCache.h"

extern "C" {

{{#container}}{{#functions}}
{{#ifPredicate "returnsOpaqueHandle"}}jlong{{/ifPredicate}}{{!!
}}{{#unlessPredicate "returnsOpaqueHandle"}}{{resolveName returnType}}{{/unlessPredicate}}
{{>jni/FunctionSignature}}
{{#set function=this}}{{#resolveName function "C++"}}{{#set cppMethodName=this}}{{#function}}{{!!
}}{{>jniMethod}}{{/function}}{{/set}}{{/resolveName}}{{/set}}

{{/functions}}
{{#properties}}{{#set property=this}}{{#getter}}
{{resolveName returnType}}
{{>jni/FunctionSignaturePrefix}}_{{resolveName property "" "getter"}}{{!!
}}(JNIEnv* _jenv, jobject _jinstance)
{{#set function=this}}{{#resolveName property "C++" "getter"}}{{#set cppMethodName=this}}{{#function}}{{!!
}}{{>jniMethod}}{{/function}}{{/set}}{{/resolveName}}{{/set}}

{{/getter}}{{#setter}}
void
{{>jni/FunctionSignaturePrefix}}_{{resolveName property "" "setter"}}{{!!
}}(JNIEnv* _jenv, jobject _jinstance{{#parameters}}, {{resolveName typeRef}} j{{resolveName}}{{/parameters}})
{{#set function=this}}{{#resolveName property "C++" "setter"}}{{#set cppMethodName=this}}{{#function}}{{!!
}}{{>jniMethod}}{{/function}}{{/set}}{{/resolveName}}{{/set}}

{{/setter}}{{/set}}{{/properties}}
{{#if hasInterfaceParent}}{{#parentMethods}}
{{resolveName returnType}}
{{>jni/FunctionSignature}}
{{>jniMethod}}

{{/parentMethods}}{{/if}}
{{#notInstanceOf container "LimeStruct"}}
JNIEXPORT void JNICALL
{{>jni/FunctionSignaturePrefix}}_disposeNativeHandle(JNIEnv* _jenv, jobject _jinstance, jlong _jpointerRef)
{
{{#unless isFunctionalInterface}}
    auto p_nobj = reinterpret_cast<std::shared_ptr<{{resolveName "C++ FQN"}}>*>(_jpointerRef);
    {{>common/InternalNamespace}}jni::JniWrapperCache::remove_cached_wrapper(_jenv, *p_nobj);
    delete p_nobj;
{{/unless}}{{#if isFunctionalInterface}}
    delete reinterpret_cast<{{resolveName "C++ FQN"}}*>(_jpointerRef);
{{/if}}
}

{{#ifPredicate "hasConstructors"}}
JNIEXPORT void JNICALL
{{>jni/FunctionSignaturePrefix}}_cacheThisInstance(JNIEnv* _jenv, jobject _jinstance)
{
    auto jobj = {{>common/InternalNamespace}}jni::make_non_releasing_ref(_jinstance);
    auto long_ptr = {{>common/InternalNamespace}}jni::get_field_value(_jenv, jobj, "nativeHandle", (int64_t*)nullptr);
    auto nobj = *reinterpret_cast<std::shared_ptr<{{resolveName "C++ FQN"}}>*>(long_ptr);
    {{>common/InternalNamespace}}jni::JniWrapperCache::cache_wrapper(_jenv, nobj, jobj);
}
{{/ifPredicate}}
{{/notInstanceOf}}
{{#hasNativeEquatable}}
jboolean
{{#set javaMethodName="equals"}}{{>jni/FunctionSignaturePrefix}}{{/set}}, jobject jrhs)
{
    if (_jinstance == nullptr || jrhs == nullptr) {
        return _jinstance == jrhs;
    }
{{#isPointerEquatable}}
    auto jclass = {{>common/InternalNamespace}}jni::get_object_class(_jenv, _jinstance);
{{/isPointerEquatable}}
{{#isEquatable}}
    auto& jclass = {{>common/InternalNamespace}}jni::get_cached_native_base_class();
{{/isEquatable}}
    if (!_jenv->IsInstanceOf(jrhs, jclass.get())) {
        return false;
    }
    auto lhs = {{#set jobjectName="_jinstance"}}{{>sharedInstance}}{{/set}}
{{#isPointerEquatable}}
    auto rhs = {{#set jobjectName="jrhs" cppFullyQualifiedName="void"}}{{>sharedInstance}}{{/set}}
    return *lhs == *rhs;
{{/isPointerEquatable}}
{{#isEquatable}}
    auto rhs = {{#set jobjectName="jrhs"}}{{>sharedInstance}}{{/set}}
    return **lhs == **rhs;
{{/isEquatable}}
}

jint
{{#set javaMethodName="hashCode"}}{{>jni/FunctionSignature}}{{/set}}
{
    auto pInstanceSharedPointer = {{#set jobjectName="_jinstance"}}{{>sharedInstance}}{{/set}}
    return {{>common/InternalNamespace}}hash<std::shared_ptr<{{resolveName "C++ FQN"}}> >()(*pInstanceSharedPointer);
}
{{/hasNativeEquatable}}
}
{{/container}}{{!!

}}{{+sharedInstance}}{{!!
}}reinterpret_cast<std::shared_ptr<{{resolveName container "C++ FQN"}}>*> (
{{>getNativeHandle}});
{{/sharedInstance}}{{!!

}}{{+getNativeHandle}}
        {{>common/InternalNamespace}}jni::get_field_value(
            _jenv,
            {{>common/InternalNamespace}}jni::make_non_releasing_ref({{jobjectName}}),
            "nativeHandle",
            (int64_t*)nullptr){{!!
}}{{/getNativeHandle}}{{!!

}}{{+jniMethod}}
{
{{#parameters}}
{{#unlessPredicate typeRef "isJniPrimitive"}}
    {{resolveName typeRef "C++"}} {{resolveName}} = {{>common/InternalNamespace}}jni::convert_from_jni(_jenv,
            {{>common/InternalNamespace}}jni::make_non_releasing_ref(j{{resolveName}}),
            ({{resolveName typeRef "C++"}}*)nullptr);
{{/unlessPredicate}}{{#ifPredicate typeRef "isJniPrimitive"}}
    {{resolveName typeRef "C++"}} {{resolveName}} = j{{resolveName}};
{{/ifPredicate}}
{{/parameters}}
{{#unless isStatic}}{{#notInstanceOf container "LimeStruct"}}{{#unless isFunctionalInterface}}
    auto pInstanceSharedPointer = {{#set jobjectName="_jinstance"}}{{>sharedInstance}}{{/set}}
{{/unless}}{{#if isFunctionalInterface}}
    auto pInstanceSharedPointer = reinterpret_cast<{{resolveName container "C++ FQN"}}*>(
{{#set jobjectName="_jinstance"}}{{>getNativeHandle}}{{/set}});
{{/if}}{{/notInstanceOf}}{{!!
}}{{#instanceOf container "LimeStruct"}}
    auto _ninstance = {{>common/InternalNamespace}}jni::convert_from_jni(_jenv,
        {{>common/InternalNamespace}}jni::make_non_releasing_ref(_jinstance),
        ({{resolveName container "C++ FQN"}}*)nullptr);
{{/instanceOf}}{{/unless}}

{{#if thrownType}}
    auto nativeCallResult = {{>cppMethodCall}}
{{#instanceOf exception.errorType.type.actualType "LimeEnumeration"}}
    auto errorCode = nativeCallResult{{#unless returnType.isVoid}}.error(){{/unless}};
    if ({{#unless returnType.isVoid}}!nativeCallResult.has_value(){{/unless}}{{#if returnType.isVoid}}errorCode{{/if}})
    {
        auto nErrorValue = static_cast<{{resolveName exception.errorType "C++ FQN"}}>(errorCode.value());
        auto jErrorValue = {{>common/InternalNamespace}}jni::convert_to_jni(_jenv, nErrorValue);
{{/instanceOf}}{{#notInstanceOf exception.errorType.type.actualType "LimeEnumeration"}}
    if (!nativeCallResult.has_value())
    {
        auto jErrorValue = {{>common/InternalNamespace}}jni::convert_to_jni(_jenv, nativeCallResult.error());
{{/notInstanceOf}}
        auto exceptionClass = {{>common/InternalNamespace}}jni::find_class(_jenv, "{{resolveName exception}}");
        auto theConstructor = _jenv->GetMethodID(exceptionClass.get(), "<init>", "({{resolveName exception.errorType "signature"}})V");
        auto exception = {{>common/InternalNamespace}}jni::new_object(_jenv, exceptionClass, theConstructor, jErrorValue);
        _jenv->Throw(static_cast<jthrowable>(exception.release()));{{#unless returnType.isVoid}}
        return {{#ifPredicate "returnsOpaqueHandle"}}0{{/ifPredicate}}{{#unlessPredicate "returnsOpaqueHandle"}}{{!!
        }}{{#unlessPredicate returnType.typeRef "isJniPrimitive"}}nullptr{{/unlessPredicate}}{{!!
        }}{{#ifPredicate returnType.typeRef "isJniPrimitive"}}nativeCallResult.unsafe_value(){{/ifPredicate}}{{/unlessPredicate}};{{/unless}}
    }{{#unless returnType.isVoid}}
    auto result = nativeCallResult.unsafe_value();{{/unless}}
{{/if}}
{{#unless thrownType}}    {{#unless returnType.isVoid}}auto result = {{/unless}}{{>cppMethodCall}}{{/unless}}{{!!
}}{{#unless returnType.isVoid}}
    {{#ifPredicate "returnsOpaqueHandle"}}auto nSharedPtr = new (::std::nothrow) {{!!
    }}::std::shared_ptr< {{resolveName returnType "C++ FQN"}} >(result);
    if (nSharedPtr == nullptr)
    {
        auto exceptionClass = {{>common/InternalNamespace}}jni::find_class(_jenv, "java/lang/OutOfMemoryError");
        _jenv->ThrowNew(exceptionClass.get(), "Cannot allocate native memory.");
        return 0;
    }
    return reinterpret_cast<jlong>(nSharedPtr);{{/ifPredicate}}{{!!
}}{{#unlessPredicate "returnsOpaqueHandle"}}return {{#unlessPredicate returnType.typeRef "isJniPrimitive"}}{{!!
}}{{>common/InternalNamespace}}jni::convert_to_jni(_jenv, result).release(){{/unlessPredicate}}{{!!
}}{{#ifPredicate returnType.typeRef "isJniPrimitive"}}result{{/ifPredicate}};{{/unlessPredicate}}{{/unless}}
}
{{/jniMethod}}{{!!

}}{{+cppMethodCall}}{{!!
}}{{#unless isFunctionalInterface}}{{#if isStatic}}{{resolveName container "C++ FQN"}}::{{/if}}{{!!
}}{{#unless isStatic}}{{#notInstanceOf container "LimeStruct"}}(*pInstanceSharedPointer)->{{/notInstanceOf}}{{!!
}}{{#instanceOf container "LimeStruct"}}_ninstance.{{/instanceOf}}{{/unless}}{{!!
}}{{cppMethodName}}{{/unless}}{{#if isFunctionalInterface}}(*pInstanceSharedPointer){{/if}}{{!!
}}({{#parameters}}{{resolveName}}{{#iter.hasNext}},{{/iter.hasNext}}{{/parameters}});
{{/cppMethodCall}}
